pipeline {
  agent {
    kubernetes {
      yaml """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: kaniko
    image: gcr.io/kaniko-project/executor:debug
    command: ["cat"]
    tty: true
  - name: git
    image: alpine/git
    command: ["cat"]
    tty: true
  - name: kubectl
    image: bitnami/kubectl:latest
    command: ["cat"]
    tty: true
  - name: argocd
    image: alpine:3.18
    command: ["cat"]
    tty: true
"""
      defaultContainer 'kaniko'
    }
  }

  environment {
    DOCKERHUB_USERNAME = credentials('cheeza42-username')
    DOCKERHUB_PASSWORD = credentials('cheeza42-password')
    IMAGE_NAME = 'docker.io/cheeza42/dockerizing-project'
    DOCKERFILE_PATH = 'dockerfile'
    BUILD_CONTEXT = '.'

    GITOPS_REPO_URL = 'https://github.com/cheeza42/Rolling_project_part_2.git'
    GITOPS_CREDENTIALS = 'github-creds'
    GITOPS_BASE_BRANCH = 'main'
    GITOPS_BRANCH = 'env-prod'
    MANIFEST_FILE = 'helm_chart_projct/values-prod.yaml'
    CHART_SRC_DIR = 'helm_chart_projct'
    CHART_DST_DIR = 'helm_chart_projct'

    ARGOCD_SERVER = 'argocd-server.argocd.svc.cluster.local:443'
    ARGOCD_APP = 'myapp-prod'
    ARGOCD_PASSWORD = credentials('argocd-password')
  }

  stages {

    stage('Clone Repository') {
      steps {
        git branch: 'main', url: 'https://github.com/cheeza42/Rolling_project_part_2.git'
      }
    }

    stage('Compute Tag') {
      steps {
        script {
          def ts = sh(returnStdout: true, script: "date +%Y%m%d-%H%M%S").trim()
          env.IMAGE_TAG = "${ts}"
          echo "IMAGE_TAG=${env.IMAGE_TAG}"
        }
      }
    }

    stage('Parallel Checks') {
      parallel {
        stage('Linting') {
          steps {
            sh 'echo "[MOCK] lint passed"'
          }
        }
        stage('Security Scan') {
          steps {
            sh 'echo "[MOCK] security scan passed"'
          }
        }
      }
    }

    stage('Build & Push (Kaniko)') {
      steps {
        sh """
          set -e
          mkdir -p /kaniko/.docker
          AUTH=\$(printf "%s" "${DOCKERHUB_USERNAME}:${DOCKERHUB_PASSWORD}" | base64 | tr -d '\\n')
          printf '{"auths":{"https://index.docker.io/v1/":{"auth":"%s"}}}\n' "\$AUTH" > /kaniko/.docker/config.json
          DF_REL="\${DOCKERFILE_PATH#\${BUILD_CONTEXT}/}"
          [ "\$DF_REL" = "\${DOCKERFILE_PATH}" ] && DF_REL="\${DOCKERFILE_PATH}"
          test -f "\${BUILD_CONTEXT}/\${DF_REL}" || { echo "Dockerfile not found at \${BUILD_CONTEXT}/\${DF_REL}"; exit 1; }
          /kaniko/executor \
            --verbosity=debug \
            --context="\${BUILD_CONTEXT}" \
            --dockerfile="\${DOCKERFILE_PATH}" \
            --destination="\${IMAGE_NAME}:\${IMAGE_TAG}" \
            --destination="\${IMAGE_NAME}:latest"
        """
      }
    }

    stage('gitops-preflight') {
      steps {
        container('git') {
          withCredentials([usernamePassword(credentialsId: "${GITOPS_CREDENTIALS}", usernameVariable: 'G_USER', passwordVariable: 'G_TOKEN')]) {
            sh '''
              set -e
              GIT_CURL_VERBOSE=1 git ls-remote "https://${G_USER}:${G_TOKEN}@${GITOPS_REPO_URL#https://}" HEAD
            '''
          }
        }
      }
    }

    stage('gitops-git-safe') {
      steps {
        container('git') {
          sh 'git config --global --add safe.directory "*" || true'
        }
      }
    }

    stage('gitops-init-branch') {
      steps {
        container('git') {
          withCredentials([usernamePassword(credentialsId: "${GITOPS_CREDENTIALS}", usernameVariable: 'G_USER', passwordVariable: 'G_TOKEN')]) {
            sh '''
              set -e
              export GIT_TERMINAL_PROMPT=0
              rm -rf gitops-repo
              mkdir -p gitops-repo
              cd gitops-repo

              git init
              git remote add origin "https://${G_USER}:${G_TOKEN}@${GITOPS_REPO_URL#https://}"

              git fetch --depth=1 origin ${GITOPS_BASE_BRANCH}
              git checkout -B ${GITOPS_BASE_BRANCH} origin/${GITOPS_BASE_BRANCH} || git checkout -B ${GITOPS_BASE_BRANCH}

              if git ls-remote --exit-code --heads origin ${GITOPS_BRANCH} >/dev/null 2>&1; then
                git fetch --depth=1 origin ${GITOPS_BRANCH}
                git checkout -B ${GITOPS_BRANCH} origin/${GITOPS_BRANCH}
              else
                git checkout -B ${GITOPS_BRANCH} ${GITOPS_BASE_BRANCH}
                git push -u origin ${GITOPS_BRANCH}
              fi
            '''
          }
        }
      }
    }

    stage('gitops-seed-once') {
      steps {
        container('git') {
          withCredentials([usernamePassword(credentialsId: "${GITOPS_CREDENTIALS}", usernameVariable: 'G_USER', passwordVariable: 'G_TOKEN')]) {
            dir('gitops-repo') {
              sh '''
                set -e
                export GIT_TERMINAL_PROMPT=0

                git remote set-url origin "https://${G_USER}:${G_TOKEN}@${GITOPS_REPO_URL#https://}"
                git checkout ${GITOPS_BRANCH}
                git pull --ff-only origin ${GITOPS_BRANCH} || true

                git config user.email "jenkins@local"
                git config user.name "jenkins"

                mkdir -p environments/prod
                [ -d "${CHART_DST_DIR}" ] || cp -R "${WORKSPACE}/${CHART_SRC_DIR}" "${CHART_DST_DIR}"

                if [ ! -f "${MANIFEST_FILE}" ]; then
                  printf "image: %s:%s\n" "${IMAGE_NAME}" "${IMAGE_TAG}" > "${MANIFEST_FILE}"
                fi

                git add "${CHART_DST_DIR}" "${MANIFEST_FILE}" || true
                git diff --cached --quiet || { git commit -m "seed gitops"; git push origin ${GITOPS_BRANCH}; }
              '''
            }
          }
        }
      }
    }

    stage('gitops-update') {
      steps {
        container('git') {
          withCredentials([usernamePassword(credentialsId: "${GITOPS_CREDENTIALS}", usernameVariable: 'G_USER', passwordVariable: 'G_TOKEN')]) {
            dir('gitops-repo') {
              sh '''
set -e
export GIT_TERMINAL_PROMPT=0

git remote set-url origin "https://${G_USER}:${G_TOKEN}@${GITOPS_REPO_URL#https://}"

git fetch origin ${GITOPS_BRANCH}
git checkout ${GITOPS_BRANCH}
git reset --hard origin/${GITOPS_BRANCH}

git config user.email "jenkins@local"
git config user.name "jenkins"

mkdir -p "$(dirname "${MANIFEST_FILE}")"

if [ ! -f "${MANIFEST_FILE}" ]; then
  printf "image: %s:%s\n" "${IMAGE_NAME}" "${IMAGE_TAG}" > "${MANIFEST_FILE}"
else
  if grep -qE '^[[:space:]]*image:[[:space:]]' "${MANIFEST_FILE}"; then
    sed -i 's|^[[:space:]]*image:.*|image: '"${IMAGE_NAME}"':'"${IMAGE_TAG}"'|' "${MANIFEST_FILE}"
  else
    printf "image: %s:%s\n" "${IMAGE_NAME}" "${IMAGE_TAG}" | cat - "${MANIFEST_FILE}" > "${MANIFEST_FILE}.tmp" && mv "${MANIFEST_FILE}.tmp" "${MANIFEST_FILE}"
  fi
fi

git add "${MANIFEST_FILE}" || true
git commit -m "env-prod: set image ${IMAGE_NAME}:${IMAGE_TAG}" || echo "nothing to commit"
git push origin ${GITOPS_BRANCH}
'''
            }
          }
        }
      }
    }

    stage('ArgoCD Sync env-prod') {
      steps {
        container('argocd') {
          sh """
            set -e
            apk add --no-cache curl
            curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64
            chmod +x /usr/local/bin/argocd
            
            CLEAN_PASS=\$(printf '%s' "${ARGOCD_PASSWORD}" | tr -d '\\r\\n')
            
            argocd login ${ARGOCD_SERVER} --username admin --password "${ARGOCD_PASSWORD}" --grpc-web --insecure
            argocd app sync ${ARGOCD_APP} --grpc-web
            argocd app wait ${ARGOCD_APP} --health --sync --timeout 300 --grpc-web
          """
        }
      }
    }

  }

  post {
    success { echo "done: ${IMAGE_NAME}:${IMAGE_TAG} -> ${GITOPS_BRANCH}" }
    failure { echo 'failed' }
  }
}
