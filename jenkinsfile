pipeline {
  agent {
    kubernetes {
      yaml """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: kaniko
    image: gcr.io/kaniko-project/executor:debug
    command: ["cat"]
    tty: true
"""
      defaultContainer 'kaniko'
    }
  }

  environment {
    DOCKERHUB_USERNAME = credentials('cheeza42-username')
    DOCKERHUB_PASSWORD = credentials('cheeza42-password')
    IMAGE_NAME      = 'docker.io/cheeza42/dockerizing-project'
    DOCKERFILE_PATH = 'dockerfile'
    BUILD_CONTEXT   = '.'
  }

  parameters {
    booleanParam(name: 'DEPLOY_TO_MINIKUBE', defaultValue: false, description: 'If true, run real Helm deploy to Minikube')
  }

  stages {
    stage('Clone Repository') {
      steps {
        git branch: 'main', url: 'https://github.com/cheeza42/Rolling_project_part_2.git'
      }
    }

    stage('Compute Tag') {
      steps {
        script {
          def ts = sh(returnStdout: true, script: "date +%Y%m%d-%H%M%S").trim()
          env.IMAGE_TAG = "${ts}"
          echo "IMAGE_TAG=${env.IMAGE_TAG}"
        }
      }
    }

    stage('Parallel Checks') {
      parallel {
        stage('Linting') {
          steps {
            sh '''
              echo "[MOCK] flake8/hadolint/shellcheck passed (skipped for Kaniko setup)"
            '''
          }
        }
        stage('Security Scan') {
          steps {
            sh '''
              echo "[MOCK] bandit/trivy scan passed (skipped for Kaniko setup)"
            '''
          }
        }
      }
    }

    stage('Build & Push (Kaniko)') {
      steps {
        sh '''
          set -e
          echo "==> Docker auth"
          mkdir -p /kaniko/.docker
          AUTH=$(printf "%s" "${DOCKERHUB_USERNAME}:${DOCKERHUB_PASSWORD}" | base64 | tr -d '\\n')
          printf '{"auths":{"https://index.docker.io/v1/":{"auth":"%s"}}}\n' "$AUTH" > /kaniko/.docker/config.json
          wc -c /kaniko/.docker/config.json

          DF_REL="${DOCKERFILE_PATH#${BUILD_CONTEXT}/}"
          [ "$DF_REL" = "$DOCKERFILE_PATH" ] && DF_REL="$DOCKERFILE_PATH"
          test -f "${BUILD_CONTEXT}/${DF_REL}" || { echo "Dockerfile not found at ${BUILD_CONTEXT}/${DF_REL}"; ls -la "${BUILD_CONTEXT}"; exit 1; }

          echo "==> Kaniko build & push"
          /kaniko/executor \
            --verbosity=debug \
            --context="${BUILD_CONTEXT}" \
            --dockerfile="${DOCKERFILE_PATH}" \
            --destination="${IMAGE_NAME}:${IMAGE_TAG}" \
            --destination="${IMAGE_NAME}:latest"
        '''
      }
    }

    stage('Deploy Dry-Run (no changes)') {
      steps {
        sh '''
          echo "==> Helm Dry-Run (printing commands only, no cluster changes)"
          CHART_PATH="${WORKSPACE}/helm_chart_projct"
          echo "kubectl config use-context minikube"
          echo "helm upgrade --install myapp \\"${CHART_PATH}\\" \\
            --set deployment.imagename=docker.io/cheeza42/dockerizing-project \\
            --set deployment.imagetag=${IMAGE_TAG} \\
            --namespace default"
          echo "kubectl rollout status deployment/myapp -n default"
          echo "kubectl get pods,svc -n default"
        '''
      }
    }

    stage('Deploy to Minikube (Helm)') {
      when { expression { return params.DEPLOY_TO_MINIKUBE } }
      steps {
        sh '''
          echo "==> Starting Helm deploy to Minikube"
          CHART_PATH="${WORKSPACE}/helm_chart_projct"

          # NOTE: This stage assumes kubectl and helm are available in the agent container.
          kubectl config use-context minikube

          helm upgrade --install myapp "${CHART_PATH}" \
            --set deployment.imagename=docker.io/cheeza42/dockerizing-project \
            --set deployment.imagetag=${IMAGE_TAG} \
            --namespace default

          kubectl rollout status deployment/myapp -n default
          kubectl get pods,svc -n default
        '''
      }
    }
  }

  post {
    success { echo "Pipeline completed successfully. Image pushed: ${IMAGE_NAME}:${IMAGE_TAG}" }
    failure { echo 'Pipeline failed! Check logs for details.' }
  }
}
